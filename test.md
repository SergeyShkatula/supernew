![толкаем-тянем](https://media.tenor.com/P9sbFdr_13MAAAAC/can-you-feel-my-heart-oliver-sykes.gif)
И теперь надо выгрузить инструкцию.
# Инструкция по работе с Git#

чтобы создать новый репозиторий я использовал команду:  
> **git init** - создание нового пустого репозитория.  

Чтобы сохранить файл, мы используем:
> **git add filename**  
> **git add .** - сохраняет абсолютно все файлы  
 косячу в одну каску  
 подскажи пожалуйста как перемещаться по коммитам
 ## Вспомнил!## 

>**git add first.txt** - добавить файл

>**git commit** - сохранить -m (коммент)

>**git diff** отличие файлов (сохраненного, текущего)

>**git log** посмотреть журнал изменений

>**git status** - текущий статус

>**git checkout master** - вернуться к актуальному состоянию
 
 **git checkout <хэш-код коммита>** Эта команда позволяет переключаться между коммитами. Просто укажите хэш-код интересующего вас коммита, и Git переключит ваш рабочий каталог и индекс на состояние, которое было в этом коммите.

>**git branch** - посмотреть ветки branch -d - удалить ветку
  
>**git branch file name** - добавить ветку  

>**qit merge** - слияние веток  

 **git commit -am "jj"** - слияние функций add и commit для отслеживаемых репозиториев  

 **git log graph** - лог в граффике  

 **git clone  https** - подтянуть репозиторий с инета  

 **git pull** - скачать изменения с репозитория и замерджить  
 
 **git remote add origin path** - устанавливает в нашем лок репозитории путь к удаленному.
 
 **git push** - выгрузить  
 ** git fetch


# *Cделать pull request*
* Делаем ащкл репозитория
* Делаем clone Своей версии репозитория*  
* Создаем новую ветку и в НЕЕ вносим свои изменения
* Фиксируем изменения(commit)  
* Отправляем свою версию в свой гит
* На сайте Гит нажимаем кнопку pull request. 



![толкаем-тянем](https://media.tenor.com/7KBEdGIKEJsAAAAC/kazoo.gif)

Вот это да!!!!!!

git diff без команды - посмотреть все незакомиченные изменения


## **LInux**

## Сеть
На практике пользователю необходимо уметь просматривать сетевые настройки сервера, а также уметь проводить простейшую диагностику сетевых проблем.

Ниже приведены несколько примеров наиболее часто используемых команд:

# руководство (справочная информация)
man <utility> # просмотр справочной информации по утилите
<utility> --help # просмотр справочной информации по утилите

# просмотр сетевых настроек сервера
ip a # IP адреса
ip n # ARP таблица
cat /etc/resolv.conf # конфигурация DNS
sudo netstat -tulpn # открытые порты
sudo ss -tulpn # открытые порты (молодежный вариант)

# диагностика сетевых проблем
nslookup <hostname> # проверка разрешения DNS имени
ping <host> # отправка ICMP пакетов до хоста
traceroute <host> # трассировка до хоста UDP пакетами
telnet <host> <port> # проверка доступности TCP порта на хосте
nmap <host> # сетевое сканирование хоста
nmap -p T:<port> <host> # проверка доступности TCP порта на хосте (молодежный вариант)
nmap -p U:<port> <host> # проверка доступности UDP порта на хосте (молодежный вариант)
ss -ntlp - инфа по портам


# руководство (справочная информация)
man <utility> # просмотр справочной информации по утилите
<utility> --help # просмотр справочной информации по утилите

# навигация
ls -la <dir> # просмотр содержимого каталога (в том числе прав доступа)
cd <dir> # переход в каталог

# каталоги
mkdir <dir> # создание каталога
rmdir <dir> # удаление пустого каталога
rm -rf <dir> # удаление каталога с файлами

# файлы
cat <file> # вывод файла в консоль
less <file> # постраничный вывод файла
tail <file> # вывод последних строк («хвоста») файла
vi <file> # редактиврование файла текстовым редактором vi
nano <file> # редактирование файла текстовым редактором nano
cp <file> <dir> # копирование файла в каталог
mv <file> <dir> # перемещение файла в каталог (для переименования переместите файл в тот же каталог)
rm <file> # удаление файла
rm -rf <dir>/* # удаление всех файлов в каталоге

# права доступа
chown <user> <dir> # установить пользователя владельцем каталога
chown <user>:<group> <dir> # установить владельца и группу владельца каталога
chmod 644 <file> # установить права доступа rw- r-- r-- (чтение и запись для владельца, чтение для группы владельца, чтение для остальных пользователей)
сhmod 740 <file> # установить права доступа rwx r-- --- (чтение, запись и исполнение для владельца, чтение для группы владельца)
chmod u+w <file> # добавить владельцу право на запись файла
Управление пользователями
cat /etc/shadow | grep -P '^[^:]+:\$' - все пользователи с паролем


В большинстве случаев новый сервер будет выдан с рутовой учетной записью (пользователем root), которая является суперпользователем (“админом” в терминах Линукс систем). Однако, очень рекомендуется не использовать root пользователя в ежедневной работе. Для этого, вам нужно научиться управлять пользователями. Это довольно просто и логично:

useradd — создает нового пользователя, ключ -d позволяет указать домашнюю директорию;
usermod — изменяет пользователя;
userdel -r — удаляет пользователя и его домашнюю папку;
passwd $username — меняет пароль пользователя.

## *Процессы-Потребление**

Процесс может находиться в следующих статусах:

Выполнение (R, Running)
Выполнение или ожидание ЦПУ для выполнения

Сон (S, Sleep)
Прерываемое программно ожидание

Непрерываемый сон (D, Direct)
Ожидание «прямого» сигнала от аппаратной части для прерывания

Приостановлен (T, Tracing)
Отладка

Зомби (Z, Zombie)
Выполнение завершено, однако ресурсы не освобождены

Почти любой процесс (кроме процесса в статусе D) может быть принудительно прерван администратором в случае необходимости («убит»). Это не всегда безопасно, однако возможно.

Запущенные процессы требуют использования аппаратных ресурсов сервера – ЦПУ, ОЗУ, дисков, сетевых интерфейсов.

Читать подробнее: Процессы в Linux

Практика
На практике пользователю необходимо просматривать списки процессов и останавливать процессы, а также просматривать имеющиеся и потребляемые ресурсы сервера в системе.

Ниже приведены несколько примеров наиболее часто используемых команд:

# руководство (справочная информация)
man <utility> # просмотр справочной информации по утилите
<utility> --help # просмотр справочной информации по утилите

##  **ПРОЦЕССЫ**
top
kill processID
sudo ps aux
sudo kill -9 <pid> # убийство процесса по PID
sudo killall -s 9 <name> # убийство всех процессов по имени
sudo ps -ef Получить список процессов с основными атрибутами можно с помощью команды
sudo ps -p PID_процесса u
pstree -p древовидное представление
md5sum /etc/passwd & Запустить процесс в фоновом режиме
Завершение работы процесса
Комбинация клавиш CTRL + C генерирует сигнал SIGINT и отправляет его всем процессам, выполняющимся в оболочке, что приводит к завершению их работы.
Временная остановка процесса
Комбинация клавиш CTRL + Z позволяет сгенерировать сигнал SIGTSTP



# утилиты для мониторинга использования ресурсов
htop # использование ресурсов по процессам (может потребоваться установка пакета htop)
nmon # использование процессора по ядрам, памяти, дисков и др. (может потребоваться установка пакета nmon)
iostat # использование процессора в среднем по ядрам и чтение/запись по дискам

# ЦПУ
lscpu # общая информация
cat /proc/cpuinfo # подробная информация

# ОЗУ
cat /proc/meminfo # общая информация и потребление
free -h # удобное представление на основе данных из файла meminfo
ps aux --sort -rss # использование памяти по процессам

# диски
lsblk # общая информация
df -h # просмотр занятного места по разделам
du -сh <dir> # просмотр занятого места в каталоге

# сеть
/sys/class/net/<interface>/speed # просмотр максимальной скорости интерфейса

# руководство (справочная информация)
man <utility> # просмотр справочной информации по утилите
<utility> --help # просмотр справочной информации по утилите

# менеджер пакетов apt (.deb)
sudo apt install nano # установка пакета
sudo apt remove nano # удаление пакета
sudo apt autoclean # удаление кэша пакетов

# менеджер пакетов yum (.rpm) - для dnf команды полностью аналогичны
sudo yum install nano # установка пакета
sudo yum remove nano # удаление пакета
sudo yum clean all # удаление кэша пакетов

## **Работа с дисками и рейд массивами**

1. Создаем RAID-массив уровня 10 из 4 дисков:
sudo mdadm --create /dev/md0 --level=10 --raid-devices=4 /dev/sda /dev/sdb /dev/sdc /dev/sdd

2. Создаем физический том на RAID-массиве:
sudo pvcreate /dev/md0

3. Создаем группу томов (VG) на основе физического тома:
sudo vgcreate myvg /dev/md0

4. Создаем логический том (LV) размером 50% доступного места:
sudo lvcreate -l 50%VG -n mylv myvg

5. Увеличиваем размер логического тома до 100% доступного места: (sudo lvresize -L +15G /dev/dljavladlena/vlaadlen)
sudo lvextend -l 100%VG /dev/myvg/mylv

6. Создаем раздел в /etc/fstab для автоматического монтирования:
sudo echo "/dev/myvg/mylv /mnt ext4 defaults 0 0" >> /etc/fstab

7. Создаем второй RAID-массив уровня 1 из 2 дисков:
sudo mdadm --create /dev/md1 --level=1 --raid-devices=2 /dev/sde /dev/sdf

8. Добавляем новый RAID-массив к существующей группе томов:
sudo vgextend myvg /dev/md1

Чтобы создать RAID-10 из двух RAID-1 массивов, нужно выполнить следующие действия:

1. Создайте два RAID-1 массива из двух дисков каждый:
sudo mdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/sda /dev/sdb
sudo mdadm --create /dev/md1 --level=1 --raid-devices=2 /dev/sdc /dev/sdd


Чтобы проверить работу RAID-массива, вы можете выполнить следующие действия:

1. Вы можете использовать команду mdadm --detail /dev/md1 для получения подробной информации о RAID-массиве.
2. Проверьте состояние массива, выполнив команду cat /proc/mdstat. Если массив работает исправно, вы увидите информацию о состоянии, прогрессе синхронизации и другую информацию о RAID-массиве.
3. Выполните тестирование RAID-массива с помощью утилиты mdadm. Например, можно запустить команду sudo mdadm --query --detail /dev/md1, чтобы протестировать доступность массива и проверить, что все компоненты работают корректно.
4. Можно также выполнить чтение и запись данных на RAID-массив, чтобы убедиться, что все операции выполняются успешно и без ошибок.

cat /proc/mdstat, которая показывает текущее состояние вашего RAID-массива

Проверка состояния группы томов (VG):
sudo vgdisplay myvg
Проверка доступных логических томов (LV):
sudo lvdisplay

Для изменения имени жесткого диска через LVM в Linux вам понадобится выполнить несколько шагов:

1. Отмонтируйте все файловые системы, которые находятся на данном диске. Например, если диск имеет монтированную файловую систему в точке "/mnt", выполните следующую команду:

   sudo umount /mnt (sudo umount /dev/dljavladlena/mylv)

2. Деактивируйте LVM разделы, которые находятся на данном диске. Для этого используйте следующую команду, заменяя "/dev/sdXX" на адрес вашего диска:

   sudo vgchange -an /dev/sdXX

3. Измените уникальный идентификатор (UUID) LVM разделов на новое значение. Пропустите этот шаг, если не хотите менять UUID:

   sudo pvchange --uuid /dev/sdXX

4. Измените имя диска с помощью команды vgrename. Замените "oldname" на текущее имя диска, а "newname" - на новое имя, которое вы желаете присвоить диску:

   sudo vgrename oldname newname

5. Активируйте LVM разделы на данном диске с помощью команды vgchange:

   sudo vgchange -ay newname

6. Проверьте, что LVM разделы успешно активированы с помощью команды lvscan:

   sudo lvscan

7. Если вы хотите, чтобы файловая система автоматически монтировалась при каждой загрузке системы, обновите файл "/etc/fstat


Задать точку монтирования для вашего логического тома (dljavladlena-mylv) следующим образом:

1. Создайте каталог, который будет служить точкой монтирования. Например, вы можете использовать команду sudo mkdir /mnt/my_mount_point для создания каталога /mnt/my_mount_point.

2. Используйте команду sudo mount для монтирования логического тома в каталог точки монтирования. Например, если ваш логический том (dljavladlena-mylv) находится на /dev/mapper/dljavladlena-mylv, вы можете использовать следующую команду:
sudo mount /dev/mapper/dljavladlena-mylv /mnt/my_mount_point

Теперь ваш логический том будет смонтирован в каталог /mnt/my_mount_point и будет доступен для чтения и записи.

Если вам нужно задать точку монтирования в системе постоянно, вам также необходимо добавить соответствующую запись в файл /etc/fstab. Это позволит системе автоматически монтировать логический том при каждой загрузке.

Вы можете открыть файл /etc/fstab в текстовом редакторе, таком как nano, и добавить следующую строку:
/dev/mapper/dljavladlena-mylv /mnt/my_mount_point ext4 defaults 0 0

Здесь /dev/mapper/dljavladlena-mylv - это путь к вашему логическому тому, /mnt/my_mount_point - путь к каталогу точки монтирования, ext4 - тип файловой системы, defaults - параметры монтирования, и 0 0 - опции резервирования.

Сохраните изменения и закройте файл /etc/fstab. При каждой загрузке система автоматически будет монтировать логический том в указанную точку монтирования.


Даже два реквкста по задаче
ycilffffffffffffffffffffff

iph''''''yufgiil;lioug
